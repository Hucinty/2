<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Real‑Time Person Cutout — Full Green Screen Studio</title>
  <style>
    body { margin: 0; background: #0b1220; color: white; font-family: sans-serif; }
    .rotated video, .rotated canvas { transform: rotate(180deg); }
    header { padding: 10px; background: #11182a; position: sticky; top: 0; }
    header h1 { margin: 0; font-size: 18px; }
    .controls { padding: 10px; background: #11182a; display: flex; flex-wrap: wrap; align-items: center; }
    .stage { display: flex; justify-content: center; align-items: center; padding: 10px; }
    .canvas-wrap { position: relative; max-width: 100%; height: auto; }
    canvas { position: absolute; inset: 0; }
    video { display: none; }
    button, select, input { margin: 5px; padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; background: #1c2640; color: white; }
    button:disabled, select:disabled { opacity: 0.5; }
  </style>
</head>
<body>
  <header><h1>Real‑Time Person Detect — Full Green Screen Studio</h1></header>
  <div class="controls">
    <button id="btnStart">Start</button>
    <button id="btnSwitch" disabled>Switch Camera</button>
    <button id="btnRotate" disabled>Rotate 180°</button>
    <button id="btnSnapshot" disabled>Snapshot</button>
    <button id="btnRecord" disabled>Start Recording</button>
    <select id="bgMode" disabled>
      <option value="transparent">Transparent</option>
      <option value="color">Solid Color</option>
      <option value="blur">Blur</option>
      <option value="image">Custom Image</option>
    </select>
    <input type="color" id="bgColor" value="#00ff00" style="display:none;">
    <input type="file" id="bgImage" accept="image/*" style="display:none;">
    <span id="status">Initializing model…</span>
  </div>
  <div class="stage">
    <div class="canvas-wrap">
      <video id="video" playsinline muted></video>
      <canvas id="output"></canvas>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script>
    const body = document.body;
    const videoElement = document.getElementById('video');
    const outputCanvas = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const btnStart = document.getElementById('btnStart');
    const btnSwitch = document.getElementById('btnSwitch');
    const btnRotate = document.getElementById('btnRotate');
    const btnSnapshot = document.getElementById('btnSnapshot');
    const btnRecord = document.getElementById('btnRecord');
    const bgMode = document.getElementById('bgMode');
    const bgColor = document.getElementById('bgColor');
    const bgImageInput = document.getElementById('bgImage');

    let currentFacing = 'user';
    let camera;
    let bgImg = null;
    let recorder, recordedChunks = [];

    const selfieSegmentation = new SelfieSegmentation({
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
    });
    selfieSegmentation.setOptions({ modelSelection: 1 });

    selfieSegmentation.onResults(results => {
      if (!videoElement.videoWidth || !videoElement.videoHeight) return;
      outputCanvas.width = videoElement.videoWidth;
      outputCanvas.height = videoElement.videoHeight;

      const ctxOut = outputCanvas.getContext('2d');
      const mask = results.segmentationMask;
      ctxOut.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

      const mode = bgMode.value;
      if (mode === 'color') {
        ctxOut.fillStyle = bgColor.value;
        ctxOut.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
      } else if (mode === 'blur') {
        ctxOut.filter = 'blur(10px)';
        ctxOut.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
        ctxOut.filter = 'none';
      } else if (mode === 'image' && bgImg) {
        ctxOut.drawImage(bgImg, 0, 0, outputCanvas.width, outputCanvas.height);
      }

      ctxOut.globalCompositeOperation = 'destination-in';
      ctxOut.drawImage(mask, 0, 0, outputCanvas.width, outputCanvas.height);
      ctxOut.globalCompositeOperation = 'destination-over';
      if (mode === 'transparent') {
        ctxOut.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
      }
      ctxOut.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
      ctxOut.globalCompositeOperation = 'source-over';
    });

    btnStart.onclick = async () => {
      if (camera) camera.stop();
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacing } });
      videoElement.srcObject = stream;
      await videoElement.play();
      camera = new Camera(videoElement, {
        onFrame: async () => {
          await selfieSegmentation.send({ image: videoElement });
        },
        width: videoElement.videoWidth,
        height: videoElement.videoHeight
      });
      camera.start();
      btnSwitch.disabled = false;
      btnRotate.disabled = false;
      btnSnapshot.disabled = false;
      btnRecord.disabled = false;
      bgMode.disabled = false;
      statusEl.textContent = 'Running…';
    };

    btnSwitch.onclick = () => {
      currentFacing = currentFacing === 'user' ? 'environment' : 'user';
      btnStart.click();
    };

    btnRotate.onclick = () => {
      body.classList.toggle('rotated');
    };

    btnSnapshot.onclick = () => {
      const link = document.createElement('a');
      link.download = 'snapshot.png';
      link.href = outputCanvas.toDataURL('image/png');
      link.click();
    };

    btnRecord.onclick = () => {
      if (!recorder) {
        recordedChunks = [];
        recorder = new MediaRecorder(outputCanvas.captureStream());
        recorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
        recorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'recording.webm';
          link.click();
        };
        recorder.start();
        btnRecord.textContent = 'Stop Recording';
      } else {
        recorder.stop();
        recorder = null;
        btnRecord.textContent = 'Start Recording';
      }
    };

    bgMode.onchange = () => {
      bgColor.style.display = bgMode.value === 'color' ? 'inline-block' : 'none';
      bgImageInput.style.display = bgMode.value === 'image' ? 'inline-block' : 'none';
    };

    bgImageInput.onchange = e => {
      const file = e.target.files[0];
      if (file) {
        const img = new Image();
        img.onload = () => { bgImg = img; };
        img.src = URL.createObjectURL(file);
      }
    };
  </script>
</body>
</html>
